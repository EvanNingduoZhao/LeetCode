class Solution:
    def climbStairs(self, n: int) -> int:
        #edge case
        # n=1时只有一种方法 n=2时只有两种方法
        if n<=2:
            return n
        dp=[0 for _ in range(n)]
        #这里dp[0]代表有上1阶台阶有几种方法
        #dp[1]代表上2阶台阶有几种方法
        #index=stairs数量-1
        dp[0]=1
        dp[1]=2
        for i in range(2,n):
            #上到第n级台阶有两种办法，第一种时先上到第n-1阶台阶，再上一阶
            #第二种时先上到n-2阶台阶，再上两阶
            #这样一来上n即台阶有几种上法，就被分解成了上n-1阶有多少中上法+上n-2阶台阶有多少种上法的和
            #这两个sub problem，上1阶和2阶的方法数量时已知的，且算上n阶的方法数量时，上n-1和n-2的肯定都已经算过了
            dp[i]=dp[i-1]+dp[i-2]
        #dp[n-1]里存的是最后上n阶台阶有多少中上法
        return dp[n-1]

    #这个方法时最典型的DP方法，其他方法都是建立在知道了上n阶台阶的数量可以用斐波那契数列算，那些更快的logn方法都是利用
    #我们知道是斐波那契数列，用斐波那契数列的数学性质构造的用公式更快的算，没什么普遍意义